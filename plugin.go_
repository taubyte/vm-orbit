// package orbit

// import (
// 	"context"
// 	"errors"
// 	"fmt"

// 	"github.com/taubyte/go-interfaces/vm"
// 	"github.com/taubyte/vm-orbit/proto"
// 	"google.golang.org/grpc"
// )

// func (c *GRPCPluginClient) Symbols() ([]vm.FunctionDefinition, error) {
// 	resp, err := c.client.Symbols(c.ctx, &proto.Empty{})
// 	if err != nil {
// 		return nil, err
// 	}

// 	funcDefs := make([]vm.FunctionDefinition, len(resp.Functions))
// 	for idx, function := range resp.Functions {
// 		args, err := typesToBytes(function.Args)
// 		if err != nil {
// 			return nil, fmt.Errorf("getting args failed with: %s", err)
// 		}

// 		rets, err := typesToBytes(function.Rets)
// 		if err != nil {
// 			return nil, fmt.Errorf("getting returns failed with: %s", err)
// 		}

// 		funcDefs[idx] = &functionDefinition{
// 			name: function.Name,
// 			args: args,
// 			rets: rets,
// 		}
// 	}

// 	return funcDefs, nil
// }

// func (c *GRPCPluginClient) Call(ctx context.Context, module vm.Module, function string, inputs []uint64) ([]uint64, error) {
// 	moduleServer := &GRPCModuleServer{
// 		module: module,
// 	}

// 	var s *grpc.Server
// 	serverFunc := func(opts []grpc.ServerOption) *grpc.Server {
// 		s = grpc.NewServer(opts...)

// 		proto.RegisterModuleServer(s, moduleServer)

// 		return s
// 	}

// 	brokerID := c.broker.NextId()
// 	go c.broker.AcceptAndServe(brokerID, serverFunc)

// 	resp, err := c.client.Call(ctx, &proto.CallRequest{
// 		Broker:   brokerID,
// 		Function: function,
// 		Inputs:   inputs,
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	defer s.Stop()

// 	if resp.Error != nil {
// 		if resp.Error.Code != nil {
// 			return nil, fmt.Errorf("failed with code: %d", *resp.Error.Code)
// 		}

// 		return nil, fmt.Errorf("failed with: %s", resp.Error.Message)
// 	}

// 	return resp.Rets, nil
// }

// func (c *GRPCModuleClient) MemoryRead(offset uint32, size uint32) ([]byte, error) {
// 	ret, err := c.client.MemoryRead(c.ctx, &proto.ReadRequest{
// 		Broker: c.broker.NextId(),
// 		Offset: offset,
// 		Size:   size,
// 	})
// 	if err != nil {
// 		return nil, fmt.Errorf("[MODULE CLIENT] memory read failed with: %w", err)
// 	}
// 	if ret.Error != 0 {
// 		return nil, fmt.Errorf("[MODULE CLIENT] memory read failed with code: %d", ret.Error)
// 	}

// 	return ret.Data, nil
// }

// func (c *GRPCModuleClient) MemoryWrite(offset uint32, data []byte) (uint32, error) {
// 	ret, err := c.client.MemoryWrite(c.ctx, &proto.WriteRequest{
// 		Broker: c.broker.NextId(),
// 		Offset: offset,
// 		Data:   data,
// 	})
// 	if err != nil {
// 		return 0, fmt.Errorf("[MODULE CLIENT] memory write failed with: %w", err)
// 	}
// 	if ret.Error != 0 {
// 		return 0, fmt.Errorf("[MODULE CLIENT] memory write failed with: %d", ret.Error)
// 	}

// 	return ret.Written, nil
// }

// func (c *GRPCModuleServer) MemoryRead(ctx context.Context, in *proto.ReadRequest) (*proto.ReadReturn, error) {
// 	data, ok := c.module.Memory().Read(in.Offset, in.Size)
// 	if !ok {
// 		return nil, errors.New("[MODULE SERVER] memory read failed")
// 	}

// 	return &proto.ReadReturn{
// 		Data: data,
// 	}, nil
// }

// func (c *GRPCModuleServer) MemoryWrite(ctx context.Context, in *proto.WriteRequest) (*proto.WriteReturn, error) {
// 	ok := c.module.Memory().Write(in.Offset, in.Data)
// 	if !ok {
// 		return nil, errors.New("[MODULE SERVER] memory read failed")
// 	}

// 	return &proto.WriteReturn{
// 		Written: uint32(len(in.Data)),
// 	}, nil
// }
